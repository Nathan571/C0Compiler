# 词法分析模块

* ### 过滤空字符
    使用 `JavaCC` 的 `SKIP` 来过滤掉词法分析部分的空字符。<br>
    例如：
    ```
    SKIP:
    {
        " " | "\t" | "\n" | "\r"
    }
    ```

* ### 定义符号
    使用 `JavaCC` 的 `TOKEN` 来声明 `C0` 中的关键词。<br>
    例如：
    ```
    TOKEN:
    {
        <ID_TO : ["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","_","0"-"9"])*>
        |
        <NUM_TO : (["0"-"9"])+>
        |
        <MAIN_TO : "main">
    }
    ```

* ### 获取匹配的符号

    如果想获取一个 `Token` 所代表的字符，则只需要调用其`image`变量。
    例如：
    ```
    Token t = <MAIN_TO>
    System.out.println(t.image);
    //main
    ```

# 语法分析模块
* ### 语法分析所用的方法
    语法分析所用的主要是 `自顶向下` 的方法，在不会产生左递归的规则采用 
`递归向下子程序法` 的分析方法，在可能出现左递归时，在此处进行`超前搜索`。使用
 `LL(2)` 分析方法。来结果可能会导致回朔的情况。
 
* ### 子程序定义
        在子程序中，将相应的规则应该翻译成子程序的互相调用。则可以清楚的
    描述出该程序的语法。
        
    ```
    <程序> -> [<变量定义部分>] {<自定义函数定义部分>} <主函数>
    <变量定义部分> -> int id {, id};
    <自定义函数定义部分> -> ( int id | void id) '(' ')' <分程序>
    <主函数> -> void main'(' ')' <分程序>
    <分程序> -> '{' [<变量定义部分>] <语句序列> '}'
    <语句序列> -> <语句> {<语句>}
    <语句> -> <条件语句> | <循环语句> | '{'<语句序列>'}' | <自定义函数调用语句> | <赋值语句> | <返回语句> | <读语句> | <写语句> | ;
    <条件语句> -> if '('<表达式>')' <语句> [else <语句> ]
    <循环语句> -> while '(' <表达式>')' <语句>
    <自定义函数调用语句> -> <自定义函数调用>;
    <赋值语句> -> id = <表达式>;
    <返回语句> -> return ['(' <表达式> ')'] ;
    <读语句> -> scanf '(' id ')';
    <写语句> -> printf '(' [ <表达式>] ')';
    <表达式> -> [+｜-] <项> { (+｜-) <项>} 
    <项> -> <因子>｛(*｜/) <因子>｝
    <因子> -> id｜'(' <表达式>')' | num | <自定义函数调用>
    <自定义函数调用> -> id '(' ')'
    ```
    
    例如规则
    ```
    <自定义函数调用> -> id '(' ')'
    ```
    则可以在`JavaCC` 中翻译成如下的函数调用。
    ```
    /** 自定义函数调用 */
    void DefinitionFunction_CC():
    {
        Token t;
    }
    {
        //id '(' ')'
        t=<ID_TO> <LPARENTHESES_TO> <RPARENTHESES_TO>
    }
    ```
* ### 代码生成
    当子程序全部编辑完成后，就可以进行代码生成测试了。<br>

    使用如下命令进行代码生成
    ```
    java -cp C://javacc-6.0//bin//lib//javacc.jar javacc Compiler.jj
    ```
    之后就生成了相应的 `*.java` 文件。<br>
    还需要进行编译。
    ```
    javac Compiler.java
    ```
    之后就得到了程序的二进制文件了<br>
    运行如下命令进行执行。
    ```
    java Compiler
    ```
    <br>
    当然，为了测试和编译的简单性，这里使用 [npm](https://www.npmjs.com/)
    将上述的代码进行打包。<br>
    只需要运行如下代码
    
    ```
    npm start
    ```
    
    <font color="#ff6767">注意：如果此命令不能运行，则请先安装最新的 `nodejs` 和 `npm` </font>
    
* ### 语法分析正确性测试
    在执行上一步的函数后，可以先将 `Compiler.jj` 中 `16` 行的代码
    ```
    Compiler parser = new Compiler(inputstream);
    ```
    替换为
    ```
    Compiler parser = new Compiler(System.in);
    ```
    则可以进行一个符号一个符号的分析。检查验证语法分析程序的正确性。
    
# 语义分析模块

* ### 语义分析实现
    此处语义分析是在上一步语法分析生成的语法树基础上进行的。在合适的地方插入
    相应的处理代码进行语义分析 <br>
    例如：
    ```
    /** 自定义函数调用 */
    void DefinitionFunction_CC():
    {
        Token t;
    }
    {
        //id '(' ')'
        t=<ID_TO> <LPARENTHESES_TO> <RPARENTHESES_TO>
        {
            getFunctionById(t);
        }
    }
    ```
* ### 变量的声明和使用：
    * 首先，全局变量声明的变量存在全局空间表中。函数中的变量存在分程序空间中。
    
    * 函数声明也存在分程序空间中，所以，对于一个函数里的变量，它在栈底一定是它的函数声明。
    所以可以区分作用域。
    
    * 函数中定义变量时判断是在当前作用域下定义过，如果定义过，
    报错，变量重复定义。
    
    * 在单词表中寻找变量时，先在当前作用域下寻找，如果没有，
    则去全局空间寻找。如果还没有，则该函数未定义。

* ### 函数的超前调用：
    * 首先先在分程序表中寻找是否有该函数，如果没有则进行超前调用。
    
    * 生成相应的调用中间码，在超前调用表中添加该函数，并且将中间码的地址记录下来。
    
    * 当函数声明的时候，检查这个函数是否在超前调用表中，如果在，就讲更改生成
    中间代码的地址，并讲这个函数从超前调用表中删除，添加到分程序表中。
    
    * 程序扫描完成后，查看超前调用表，如果还有函数，则该函数没有声明。报出错误信息。

* ### 函数的返回值：
    * 首先，在语法树函数开始的地方做上标记，记录该函数返回值类型。
    
    * 当函数最后没有返回值时，如果返回类型为int，则报错，错误信息：
    “此函数必须返回int值变量”。
    
    * 当函数最后没有返回值时，如果返回类型为void，则自动帮函数在末尾添加return语句。

# 中间代码生成模块

# 目标代码生成模块

# 错误处理模块
* ### 错误处理模块调用的接口为：
    ```
        @param errCode 错误号
        @param errMsg 错误信息
        public static void ShowErrMsg(int errCode,String errMsg)
    ```
